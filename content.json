{"meta":{"title":"EsNaSc","subtitle":"","description":"personal blog of learning","author":"FeOAr","url":"https://github.com/FeOAr/FeOAr.github.io.git","root":"/"},"pages":[{"title":"标签","date":"2020-10-08T04:29:59.000Z","updated":"2020-10-08T04:32:13.809Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"常用命令行","slug":"常用命令行","date":"2020-10-12T16:00:00.000Z","updated":"2020-10-13T04:27:41.916Z","comments":true,"path":"2020/10/13/常用命令行/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/10/13/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/","excerpt":"","text":"常用命令行","categories":[],"tags":[{"name":"基础学习","slug":"基础学习","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"稀疏数组","slug":"稀疏数组","date":"2020-10-09T16:00:00.000Z","updated":"2020-10-10T14:00:50.625Z","comments":true,"path":"2020/10/10/稀疏数组/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/10/10/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"稀疏数组 当一个数组中大部分元素为0，或者为同一值的数组时，可以使用吸收叔叔组来保存该数组。 稀疏数组的处理方式时： 记录数组一共有几行几列，有多少个不同的值 八级有不同值的元素和行列及值记录在一个小规模数组中，从而缩小程序规模 如图，左边为原始数组，右边为稀疏数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package Base.First.Demo;public class xishushuzu &#123; public static void main(String[] args) &#123; //创建一个11*11的二维数组 //0：没有棋子，1：黑棋，2：白棋 int[][] array1 = new int[11][11]; array1[1][2] = 1; array1[2][3] = 2; //输出原始数组 System.out.println(&quot;输出原始数组&quot;); for(int[] ints : array1)&#123; for(int anInt : ints)&#123; System.out.print(anInt + &quot;\\t&quot;); &#125; System.out.println(); &#125; //转换为稀疏数组 //获取有效值的个数 int sum = 0; for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if((array1[i][j]) != 0) sum++; &#125; &#125; System.out.println(&quot;--------------分割线----------------&quot;); System.out.println(&quot;有效值的个数= &quot; + sum); //创建一个稀疏数组对应的数组 int[][] array2 = new int[sum+1][3]; array2[0][0] = 11; array2[0][1] = 11; array2[0][2] = sum; //遍历二维数组，将非零值存入数组 int count = 0; for (int i = 0; i &lt; array1.length; i++) &#123; for (int j = 0; j &lt; array1[i].length; j++) &#123; if(array1[i][j] != 0)&#123; count++; array2[count][0] = i; array2[count][1] = i; array2[count][2] = array1[i][j]; &#125; &#125; &#125; //输出稀疏数组 System.out.println(&quot;输出稀疏数组&quot;); for (int i = 0; i &lt; array2.length; i++) &#123; System.out.println(array2[i][0] + &quot;\\t&quot; +array2[i][1]+ &quot;\\t&quot; +array2[i][2]+ &quot;\\t&quot;); &#125; System.out.println(&quot;--------------分割线----------------&quot;); //还原稀疏数组，1，读取稀疏数组 int[][] array3 = new int[array2[0][0]][array2[0][1]]; //给其中的元素还原其值 for (int i = 1; i &lt; array2.length; i++) &#123; array3[array2[i][0]][array2[i][1]] = array2[i][2]; &#125; //输出 System.out.println(&quot;还原的数组&quot;); for (int[] ints: array3) &#123; for(int anInt : ints)&#123; System.out.print(anInt + &quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"基础学习","slug":"基础学习","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Java学习","slug":"Java学习pro版","date":"2020-10-07T16:00:00.000Z","updated":"2020-10-13T04:57:35.108Z","comments":true,"path":"2020/10/08/Java学习pro版/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/10/08/Java%E5%AD%A6%E4%B9%A0pro%E7%89%88/","excerpt":"","text":"Java基础语法注释，标识符，关键字Java注释 单行注释 多行注释 文档注释 Java标识符关键字 标识符 类名，变量名，方法名都称为标识符。 数据类型 强类型语言 Java数据类型有两类 基本类型（primitive type） 引用类型（reference type） boolean (true/false&lt;—defaule) 1boolean flag = true; byte (节约空间) short / int / long 123456789101112131415161718//eg.long c1 = 100324532456L //进制拓展 二进制0b 八进制0 十进制 十六进制0xint i = 10;int i2 = 010; //八进制int i3 = 0x10; //十六进制System.out.println(i);System.out.println(i2);System.out.println(i3);//JDK7以后，数字之间可以加下划线分割int money = 10_0000_0000;int a = 20;long b = a * money; //b会溢出解决方法 -&gt; long b = a * (long)money;或 int money = 10_0000_0000L;P.S. &#x27;L&#x27;一般大写 float / double 123float f1 = 1.23fdouble d1 = 4.457d// 浮点数有损失，可以尝试使用BigDecimal 数学工具类 char ( \\u0000 - \\uffff || Unicode编码 2字节 || String属于类) 1char c3 = &#x27;\\u0061&#x27; 整数数拓展 浮点数拓展 字符拓展 12String s;s.equals(&quot;hello&quot;); //判断字符串s和hello是否相等 强制转换 （类型）变量名 转义字符 基本类型（一种变量）—-&gt; 结构体 （多种变量捆绑） —-&gt; 类（多种变量 + 方法） 类型转换 低 ——–（自动）———–&gt; 高（字节） ​ &lt;——–（强制）———– byte, short, char —&gt; int —&gt; long —&gt; float —&gt; double (小数优先级大于整数) 123456/*1.不能转换布尔值2.不能将对象类型转换为不相干的类型3.高容量转低容量时，强制转换4.转换时可能存在内存溢出或精度问题*/ 变量常量==不建议一行定义多个变量== 类变量 实例变量 局部变量 类成员变量：首字母小写和驼峰原则 局部变量：首字母小写和驼峰原则 常量 (final) ：大写字母和下划线 类名：首字母小写和驼峰原则 方法名：首字母小写和驼峰原则 运算符 包机制，JavaDoc包机制 package pk1[. pkg2[. pkg3…….]] eg. com.baidu.www ———&gt; com\\baidu\\www import package1[.package2….].(classname|*); eg. import com. baidu. www. *; JavaDoc JavaDoc命令是用来生成自己的API文档 API: API（Application Programming Interface，应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。 [1] 用来提供应用程序与开发人员基于某软件或硬件得以访问的一组例程，而又无需访问源码，或理解内部工作机制的细节。 1234567891011121314151617181920//eg.package Base.First.Demo;/** * @author zhr * @version 1.0 */public class Demo01 &#123; String name; /** * * @param name * @return * @throws Exception */ public String test(String name) throws Exception&#123; return name; &#125;&#125; Java流程控制1.用户交互Scanner Scanner s = new Scanner(System.in); 通过Scanner类的next() 与 nextLine() 方法获取输入字符串，在读取前一般使用hasNext() 与hasNextLine()判断是或否还有输入的数据。 1234567891011121314151617181920package Base.First.Demo;import java.util.Scanner;public class Scanne &#123; public static void main(String[] args) &#123; //创建一个扫描器对象，用于接收键盘数据 Scanner scanner = new Scanner(System.in); //判断用户有没有输入字符串 System.out.println(&quot;INPUT by next:&quot;); if(scanner.hasNext())&#123; //使用next方式接收 String str = scanner.next(); System.out.println(&quot;OUTPUT:&quot; + str); &#125; //凡是属于IO流的类如果不关闭会一直占用资源 scanner.close(); &#125;&#125; 2.顺序结构3.选择结构 if switch switch语句中变量类型可以是byte, short, int, char, String(from Java SE 7) switch中string 通过哈希值来匹配 4.循环结构==尽量避免死循环== while while(为假跳出){ } 先判断后执行 do…while 对比while，至少执行一次 先执行后判断 for 是支持迭代的一种通用结构，是最有效最灵活的循环结构，执行次数在执行前就已确定。 Idea_Tips: 100.for 123for (int i1 = 0; i1 &lt; 100; i1++) &#123; &#125; 遍历数组 1234int[] number = &#123;1,2,3,4,5&#125;; for(int x:number)&#123; System.out.println(x); &#125; 5.break &amp; continue6.练习Java方法1.什么是方法 Java方法是解决一类问题的步骤的有序组合，方法包含于类或对象中，方法在程序中被创建，在其他地方被引用。 建议保证方法的原子性（一个函数，一个功能） 尽量保证main();的整洁干净 2.方法的定义以及调用定义 方法即函数，是一段用来完成特定功能的代码片段，一般情况下定义一个方法包含： 修饰符：可选 返回值类型 方法名 参数类型 方法体 123456修饰符 返回值类型 方法名（参数类型 参数名）&#123; ... 方法体 ... return 返回值;&#125; 调用 对象名.方法名（实参列表） Java属于值传递（值传递 / 引用传递） 3.方法重载 重载就是在一个类中，有相同的函数名称，但形参不同的函数，返回类型无所谓 4.命令行传参 src目录下，Java 包名 + 文件名 5.可变参数 Java1.5开始支持传递同类型的可变参数给一个方法 在方法声明名中，在指定参数类型后加一个省略号”…” 一个方法中只能指定一个可变参数，且必须是最后一个参数。任何普通参数都必须在其之前声明。 1public static int add(int... i)&#123;&#125; 6.递归 123456789101112package Base.First.Demo;public class digui &#123; //阶乘 public static void main(String[] args) &#123; System.out.println(f(3)); &#125; public static int f(int n)&#123; if(n == 1) return 1; else return n*f(n-1); &#125;&#125; 都是栈机制，避免太深的递归 数组1.什么是数组 2.数组声明创建 dataType[] arrayRefVar; 或 dataType arrayRefVar[]; ( 效果相同不推荐 ) 语法：dataType[] arrayRefVar = new dataType[arraySize]; 获取数组长度： arrays.length 3.数组使用及内存分析使用 For - Each循环 12345int []a=&#123;1,2,3,4,5&#125;for(int b:a)&#123; System.out.println(b);&#125; 数组做方法入参 数组做返回值 数组变量赋值后管理同一个数组。 12int []a=&#123;1,2,3,4,5&#125;int []b=a; //修改b，a也改变 静态初始化：创建+赋值 4.多维数组5.Arrays类 数组的工具类java.util.Arrays，帮助对数组进行一些基本操作 Arrays类中的方法都是static修饰的静态方法，在使用时可以直接使用类名进行调用，”不强制用”使用对象来调用 常用方法： 给数组赋值：fill 给数组排序：sort，升序 比较数组：通过equals比较数组中元素值是否相等 查找数组元素：通过binarySearch方法能对排序好的数组二分法查找操作 12345678910111213//示例package Base.First.Demo;import java.util.Arrays;public class digui &#123; public static void main(String[] args) &#123; int []a=&#123;1,2,3,4,5&#125;; System.out.println(Arrays.toString(a)); &#125;&#125; 6.稀疏数组（具体参考该篇博客笔记） 面向对象面向对象 面向过程 步骤清晰简单，适合处理简单问题 面向过程 物以类聚，分类 的思维模式，解决问题前先对问题进行细分为类，对每个分类单独思考，再在单独分类下进行面向过程的思考。 适合处理复杂问题 对于描述复杂的事物，为了从宏观上把握，从整体上分析，我们需要使用面向对象的思路来分析整个系统。但是，具体的微观操作，仍需要面向过程的思路处理。 面向对象编程的本质就是：以类的方式组织代码，以对象的方式组织（封装）数据。 抽象 三大特性：封装，继承，多态 对象是类的具体表现 在程序中，先有类后有对象 方法（定义，调用） 静态方法，可以直接通过（类名.函数名）调用 非静态方法，必须将类实例化，（对象名.函数名）调用 形参实参 值传递与引用传递 this关键字 构造器 使用new关键字本质是在调用构造函数（构造器） 用来初始化值 IDEA中（ALT + INSERT）自动生成构造器 注意：定义有参构造函数后若要使用无参构造函数必须显示的（专门写一个无参构造函数）定义一个无参构造函数 this. (此处this一般指当前类) = （传入值） 封装 属性私有，get / set 高内聚，低耦合（类的内部数据操作细节自己完成，仅暴露少量的方法给外部使用） 继承 extands 意思是“扩展”，子类是父类的扩展，派生类为基类的扩展 继承是类之间的一种关系，除此之外还有以来，组合，聚合等 12//eg.public class Student extends Person&#123;&#125; 子类可以继承父类的所有方法（公有继承）,私有属性无法继承 Tips：CTRL + H 在IDEA中打开继承树 Java中所有类都默认直接或间接继承Object类，（祖宗类） Java 每个类只能继承一个类（单根继承原则） 若不写extends , Java都默认继承 Java.lang.Object 类 super(); 先调用父类的无参构造函数再调用自己的无参构造函数。 必须只能出现在子类的方法或构造函数中 super与this不能同时调用构造方法 super(一个形参); 先调用父类的一参构造函数再调用自己的一参构造函数。 。。。 父类没有无参构造函数则子类也没有 重写（override） 重写都是方法的重写，与属性无关 重写在子父类之间，定义必须相同，方法体不同；重载在一个类中 修饰符范围可以扩大但不能缩小（public &gt; protected &gt; default &gt; private） 抛出异常：范围可以缩小但不能扩大；eg. ClassNotFoundException -&gt; Exception(大) 静态方法与非静态方法 静态方法：方法的调用只和左边定义的数据类型有关，对象能执行哪些方法，主要看对象左边的类型与右边关系不大 非静态：重写 多态* 同一个方法可以根据发送对象的不同而采取多种不同的行为方式 多态是方法的多态，属性没有多态 一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多 存在的条件：继承关系，子类重写父类的方法，父类引用指向子类对象。Father f1 = new Son(); Tips : static方法属于类，不属于实例 final : 常量 private方法 类型转换带来的作用就是多态 子类继承父类所有的方法，但是子类可以重新定义一个名字，参数和父类一样的方法，该行为叫重写（覆写，覆盖，overwrite / override , not overload(重载)） 子类方法优先级高于父类 多态的作用 以统一的接口来操纵某一类中不同对象的动态行为 对象之间的解耦 Instanceof 判断一个对象是什么类型 12boolean result = obj instanceof Class //obj 为一个对象，Class 表示一个类或者一个接口当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。 具体参考 类转型 类型可以相互转型，但是只限制于有继承关系的类。 子类可以单向转化为父类（由大到小，向上转型） 1Human obj1 = new Man(); //Man extends Human 父类转为子类只有一种情况即该父类本身就从子类转化而来。 static 属性，类中只有一个，所有对象共同访问 方法，非静态方法可以直接调用静态方法，反之不行。因为static方法同类一起加载顺序在非静态之前 非静态需要用对象访问，静态可以直接类名访问，一般建议类名访问，方便看出为静态 static 静态的，Java中特殊的关键字（内存里只有一块） 可以作用在 变量，方法，类，匿名方法块 static块，只执行一次，执行顺序：static块 &gt; 匿名块 &gt; 1234567&#123; System.out.print(&quot;代码块&quot;);&#125;static&#123; System.out.print(&quot;静态代码块&quot;);&#125; 静态导入包 12345import static java.lang.Math.random . . .System.out.print(random()); //此处random函数如果没有导入，形式为Math.random() 抽象类 函数缺少函数体，该类需定义为抽象类。 关键字 abstract 可以用来修饰方法也可以用来修饰类，可以得到抽象方法，抽象类 123456//示例public abstract class Shape&#123; int area; public abstract void calRrea(); //抽象方法（函数），有一个就属于抽象类，具体类不加 abstract&#125; 抽象类无法 new创建对象，它是用来让子类继承的 抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的 抽象类也是类 抽象类中可以没有抽象方法，但由抽象方法的类一定要声明为抽象类 子类可以继承于抽象类，但一定要实现父类所有 abstract 的方法。若无法完全实现，子类也必须被定义为抽象类，只有实现父类所有 abstract 的方法才可变为完整类。 接口 如果所有方法都未实现，此类算是 接口 关键字 interface 1234//示例public interface Animal&#123; void name(String n);&#125; 普通类：只有具体实现 抽象类：具体实现和规范（抽象方法）都有 接口：只有规范接口本质是契约 类只可以继承一个类但可实现多个接口，继承（extends）与实现可以同时进行（弥补单根继承的不足） 实现（implements）一个接口必须实现所有的 abstract 方法 接口可继承多个接口 抽象类有构造函数，接口没有 抽象类可以有main，可运行，接口没有main 抽象类方法可以是private/protected，接口都是 public 接口作用 约束 定义方法，让不同人实现 public abstract public static final 接口不能被实例化，接口中没有构造方法 implements可以实现多个接口 必须要重写接口中的方法 内部类 内部类就是在一个类内部定义一个类 分为 成员内部类 静态内部类 局部内部类 匿名内部类 12345678910111213141516171819202122232425262728293031323334353637//实例//Outer.javapackage Base.First.Demo;public class Outer &#123; private int id= 10010; public void out()&#123; System.out.println(&quot;这是外部类方法&quot;); &#125; public class Inner&#123; public void in()&#123; System.out.println(&quot;这是内部类方法&quot;); &#125; //获得外部类的私有属性,若内部类为static则无法获取 public void getId()&#123; System.out.println(id); &#125; &#125;&#125;//Application.javapackage Base.First.Demo.Base;import Base.First.Demo.Outer;public class Application &#123; public static void main(String[] args) &#123; Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); outer.out(); inner.in(); inner.getId(); &#125;&#125; 一个Java文件中只能有一个 public class，但可以有多个class类 12public class void main()&#123;&#125;class Inner&#123;&#125; 异常机制（Exception）异常简述 异常指程序运行中出现的不期而至的各种状况，如：文件找不到，网络连接失败，非法参考等 异常发生在程序运行期间，它影响了正常的程序执行流程 异常分类： 检查性异常 运行时异常 错误ERROR 异常处理机制 五个关键字：try, catch, finally, throws 捕获异常 123456789101112131415161718192021//示例try&#123; //try监控区域 //这是一个代码块 &#125;catch(/*要捕获的异常类型*/ArithmeticException ae)&#123; //此处ae应该是生成的异常对象名 //捕获异常 //可以有多个catch，异常类型应由小到大，最终只生效一个，建议最后加一个大异常来见少遗漏 //若出现对应异常运行此处 &#125;catch(/*要捕获的异常类型*/NullPointerException ne)&#123; ...&#125;finally&#123; //处理善后 //可以取舍，但建议用来释放资源 //无论是否异常都运行此处 &#125; 选中 CTRL + ALT + T 有了try catch等异常处理后可以避免程序卡死 抛出异常 123public void test()throws ArithmeticException&#123;//抛到上一级，让调用其的地方捕获 throw new ArithmeticException(); //主动生成异常，一般在方法中使用 &#125; 自定义异常 只需要继承Exception类即可 参考教学视频","categories":[],"tags":[{"name":"基础学习","slug":"基础学习","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Markdown语法","slug":"MD基本语法","date":"2020-10-06T16:00:00.000Z","updated":"2020-10-07T15:24:58.838Z","comments":true,"path":"2020/10/07/MD基本语法/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/10/07/MD%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Markdown语法1.代码块 “ ```语言 “ 12345678//cpp with hello worldinclude&lt;iostream.h&gt;using namespace std;void main()&#123; cout&lt;&lt;&quot;hello wordl&quot;&lt;&lt;endl;&#125; 12import turtleprint(&quot;hello world&quot;) 2.标题123#[空格] 一级##[空格] 二级###[空格] 三级 3.字体12345678//加粗**无产阶级**//代码高亮显示==资产阶级==//删除线~~阶级斗争~~//斜体*中产阶级* 无产阶级 ==阶级斗争== 资产阶级 中产阶级 4.引用123//引用语法&gt;作者：赵航锐&gt;&gt;作者：赵航锐 作者：*** 作者 作者 5.分割线12345//分割线---//分割线*** 6.图片插入12//在线图片/本地图片![我的图片](路径) 7.超链接12&#x2F;&#x2F;超链接语法[我的码云](https:&#x2F;&#x2F;gitee.com&#x2F;feoar) 我的码云 8.列表1234567//无序列表- 目录1- 目录2- 目录3 //有序列表1.项目2.项目 目录1 目录2 目录3 项目 项目 9.表格Quick Start hello blog Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"基础学习","slug":"基础学习","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Markdown form CSDN","slug":"CSDN_MD_GRAMMAR","date":"2020-10-06T16:00:00.000Z","updated":"2020-10-07T15:30:21.869Z","comments":true,"path":"2020/10/07/CSDN_MD_GRAMMAR/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/10/07/CSDN_MD_GRAMMAR/","excerpt":"","text":"@TOC 欢迎使用Markdown编辑器你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。 新的改变我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客： 全新的界面设计 ，将会带来全新的写作体验； 在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示； 增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示； 全新的 KaTeX数学公式 语法； 增加了支持甘特图的mermaid语法^1 功能； 增加了 多屏幕编辑 Markdown文章功能； 增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间； 增加了 检查列表 功能。 功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G查找：Ctrl/Command + F替换：Ctrl/Command + G 合理的创建标题，有助于目录的生成直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式强调文本 强调文本 加粗文本 加粗文本 ==标记文本== 删除文本 引用文本 H2O is是液体。 2^10^ 运算结果是 1024. 插入链接与图片链接: link. 图片: 带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw =30x30) 居中的图片: 居中并且带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center =30x30) 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。 如何插入一段漂亮的代码片去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片. 12// An highlighted blockvar foo = &#x27;bar&#x27;; 生成一个适合你的列表 项目 项目 项目 项目1 项目2 项目3 计划任务 完成任务 创建一个表格一个简单的表格是这么创建的：| 项目 | Value || —- | —– || 电脑 | $1600 || 手机 | $12 || 导管 | $1 | 设定内容居中、居左、居右使用:---------:居中使用:----------居左使用----------:居右| 第一列 | 第二列 | 第三列 || :————: | ————-: | :————- || 第一列文本居中 | 第二列文本居右 | 第三列文本居左 | SmartyPantsSmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：| TYPE |ASCII |HTML|—————-|——————————-|—————————–||Single backticks|&#39;Isn&#39;t this fun?&#39; |’Isn’t this fun?’ ||Quotes |&quot;Isn&#39;t this fun?&quot; |”Isn’t this fun?” ||Dashes |-- is en-dash, --- is em-dash|– is en-dash, — is em-dash| 创建一个自定义列表MarkdownText-to-HTML conversion toolAuthors: JohnLuke如何创建一个注脚一个具有注脚的文本。^2 注释也是必不可少的Markdown将文本转换为 HTML。 *[HTML]: 超文本标记语言 KaTeX数学公式您可以使用渲染LaTeX数学表达式 KaTeX: Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\foralln\\in\\mathbb N$ 是通过欧拉积分 $$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt,.$$ 你可以找到更多关于的信息 LaTeX 数学表达式here. 新的甘特图功能，丰富你的文章12345678gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划一 : des3, after des2, 5d 计划二 : des4, after des3, 5d 关于 甘特图 语法，参考 这儿, UML 图表可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图： 123456789sequenceDiagram张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?李四--&gt;&gt;王五: 你最近怎么样，王五？李四--x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了&lt;br&#x2F;&gt;不适合放在一行.李四--&gt;&gt;张三: 打量着王五...张三-&gt;&gt;王五: 很好... 王五, 你怎么样? 这将产生一个流程图。: 12345graph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D 关于 Mermaid 语法，参考 这儿, FLowchart流程图我们依旧会支持flowchart的流程图： 123456789flowchatst&#x3D;&gt;start: 开始e&#x3D;&gt;end: 结束op&#x3D;&gt;operation: 我的操作cond&#x3D;&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 Flowchart流程图 语法，参考 这儿. 导出与导入导出如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。 导入如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，继续你的创作。","categories":[],"tags":[{"name":"引用备忘","slug":"引用备忘","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%BC%95%E7%94%A8%E5%A4%87%E5%BF%98/"}]},{"title":"汇编语言","slug":"汇编语言","date":"2020-10-06T16:00:00.000Z","updated":"2020-10-08T12:46:40.043Z","comments":true,"path":"2020/10/07/汇编语言/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/10/07/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","excerpt":"","text":"汇编语言1. CPU,寄存器，内存 CPU由运算器，控制器，寄存器构成 CPU引出了三种总线：地址总线，控制总线，数据总线 地址总线的宽度决定了CPU的寻址能力 数据总线的宽度决定了CPU与其他旗舰进行数据传送时一次传输的数据量 控制总线的宽度决定了CPU对系统中其他器件的控制能力 8086寄存器 8086寄存器为16位 运算器一次运算16位数据 寄存器最大宽度16位 寄存器与运算器之间的通路16位 8086有14个寄存器：AX, BX, CX, DX, SI, DI, SP, BP, IP, CS, SS, DS, ES, PSW 段寄存器：CS, SS, DS, ES 偏移地址寄存器：IP 通用寄存器为：AX, BX, CX, DX ，可以拆分位高低八位寄存器比如：AH与AL 2.汇编指令（核心） 机器码的助记符，有对应的机器码 MOV指令 eg. ​ mov ax,18 || 将18送入寄存器AX（18位立即数） ​ mov ah,78 ​ mov ax, bx || 将bx中的值移入ax || 原理是将bx中的内容复制到ax ADD指令 eg. ​ add ax,78 || ax中的值加78 ​ add ax, bx || ax和bx中的数值相加，结果存在ax中 溢出丢弃最高位，低位寄存器独立看待同样丢弃最高位 指令的操作对象位数相同 3.伪指令 没有对应的机器码，由编译器执行，计算机并不执行 4.其他符号 如+, -, *, /, 等，由编译器识别，没有对应机器码。 5.其他物理地址 段地址（16位）*16 + 偏移地址（16位）= 物理地址（20位） 20位物理地址意味着寻址能力达到2^20即1MB 以上相加过程在地址加法器中实现，然后物理地址送到I/O电路，再到地址总线到内存","categories":[],"tags":[{"name":"基础学习","slug":"基础学习","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"读书笔记","slug":"读书笔记","date":"2020-10-06T16:00:00.000Z","updated":"2020-10-07T15:28:55.057Z","comments":true,"path":"2020/10/07/读书笔记/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/10/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"读书笔记《毛泽东文选》谁是我们的敌人?谁是我们的朋友?这个问题是革命的首要问题。中国过去一切革命斗争成效甚少，其基本原因就是因为不能团结真正的朋友，以攻击真正的敌人。革命党是群众的向导，在革命中未有革命党领错了路而革命不失败的。我们的革命要有不领错路和一定成功的把握，不可不注意团结我们的真正的朋友，以攻击我们的真正的敌人。我们要分辨真正的敌友，不可不将中国社会各阶级的经济地位及其对于革命的态度，作一个大概的分析。 开篇点明了革命的关键问题，我们的敌人是谁，要革谁的命，谁将是我们的同志，谁又是潜在的敌人，谁又是潜在的队友；都需要搞明白弄清楚才能有以此为基础之一的战略制定。我想起了孟子的一篇文章中的话“得道者多助，失道者寡助。寡助之至，亲戚畔之。多助之至，天下顺之。以天下之所顺，攻亲戚之所畔，故君子有不战，战必胜矣。 ”， 意思是能行“仁政”的君王，帮助支持他的人就多，不施行“仁政”的君主，支持帮助他的人就少。支持帮助他的人少到了极点，连内外亲属也会背叛他；支持帮助他的人多到了极点，天下所有人都会归顺他。凭着天下人都归顺他的条件，去攻打那连亲属都反对背叛的君王，君子要么不战斗，（如果）战斗就一定会取得胜利。 ​ 地主阶级和买办阶级。在经济落后的半殖民地的中国，地主阶级和买办阶级完全是国际资产阶级的附庸，其生存和发展，是附属于帝国主义的。 中产阶级。这个阶级代表中国城乡资本主义的生产关系。 小资产阶级。如自耕农，手工业主，小知识阶层——学生界、中小学教员、小员司、小事务员、小律师，小商人等都属于这一类。 半无产阶级。此处所谓半无产阶级，包含：绝大部分半自耕农，贫农，小手工业者，店员，小贩等五种。 无产阶级。现代工业无产阶级约二百万人。所谓农村无产阶级，是指长工、月工、零工等雇农而言。 此外，还有数量不小的游民无产者，为失了土地的农民和失了工作机会的手工业工人。 综上所述，可知一切勾结帝国主义的军阀、官僚、买办阶级、大地主阶级以及附属于他们的一部分反动知识界，是我们的敌人。工业无产阶级是我们革命的领导力量。一切半无产阶级、小资产阶级，是我们最接近的朋友。那动摇不定的中产阶级，其右翼可能是我们的敌人，其左翼可能是我们的朋友——但我们要时常提防他们，不要让他们扰乱了我们的阵线。 这几段我有所删减，几段文字精准的抛析了当代中国社会的人员阶级结构以及比重。结合第一段，找到了革命的主力军为日后的胜利找到了同盟军。在《江泽民在庆祝建档八十周年大会上的讲话》同样也指明了中国特色社会主义事业的建设者问题，不同历史阶段的两个创造性解答，体现了我们党从现实国情，，党情和外面的世情触发，在马克思主义立场，观点，方法指导下解放思想，实事求是，团结社会各阶层，巩固自己的社会基础，扩大自己的群基础，不断提高党的社会影响力，带领革命斗争多的胜利，带领中国特色社会主义建设取得胜利的远见卓识。为并且随着时代发展，依然适用于现代社会的阶级人员构成。 一国之内，在四围白色政权的包围中，有一小块或若干小块红色政权的区域长期地存在，这是世界各国从来没有的事。这种奇事的发生，有其独特的原因。而其存在和发展，亦必有相当的条件。第一，它的发生不能在任何帝国主义的国家，也不能在任何帝国主义直接统治的殖民地[7]，必然是在帝国主义间接统治的经济落后的半殖民地的中国。因为这种奇怪现象必定伴着另外一件奇怪现象，那就是白色政权之间的战争。帝国主义和国内买办豪绅阶级支持着的各派新旧军阀，从民国元年以来，相互间进行着继续不断的战争，这是半殖民地中国的特征之一。不但全世界帝国主义国家没有一国有这种现象，就是帝国主义直接统治的殖民地也没有一处有这种现象，仅仅帝国主义间接统治的中国这样的国家才有这种现象。这种现象产生的原因有两种，即地方的农业经济(不是统一的资本主义经济)和帝国主义划分势力范围的分裂剥削政策。因为有了白色政权间的长期的分裂和战争，便给了一种条件，使一小块或若干小块的共产党领导的红色区域，能够在四围白色政权包围的中间发生和坚持下来。湘赣边界的割据，就是这许多小块中间的一小块。有些同志在困难和危急的时候，往往怀疑这样的红色政权的存在，而发生悲观的情绪。这是没有找出这种红色政权所以发生和存在的正确的解释的缘故。我们只须知道中国白色政权的分裂和战争是继续不断的，则红色政权的发生、存在并且日益发展，便是无疑的了。第二，中国红色政权首先发生和能够长期地存在的地方，不是那种并未经过民主革命影响的地方，例如四川、贵州、云南及北方各省，而是在一九二六和一九二七两年资产阶级民主革命过程中工农兵士群众曾经大大地起来过的地方，例如湖南、广东、湖北、江西等省。这些省份的许多地方，曾经有过很广大的工会和农民协会的组织，有过工农阶级对地主豪绅阶级和资产阶级的许多经济的政治的斗争。所以广州产生过三天的城市民众政权，而海陆丰、湘东、湘南、湘赣边界、湖北的黄安等地都有过农民的割据[8]。至于此刻的红军，也是由经过民主的政治训练和接受过工农群众影响的国民革命军中分化出来的。那些毫未经过民主的政治训练、毫未接受过工农影响的军队，例如阎锡山、张作霖的军队，此时便决然不能分化出可以造成红军的成分来。第三，小地方民众政权之能否长期地存在，则决定于全国革命形势是否向前发展这一个条件。全国革命形势是向前发展的，则小块红色区域的长期存在，不但没有疑义，而且必然地要作为取得全国政权的许多力量中间的一个力量。全国革命形势若不是继续地向前发展，而有一个比较长期的停顿，则小块红色区域的长期存在是不可能的。现在中国革命形势是跟着国内买办豪绅阶级和国际资产阶级的继续的分裂和战争，而继续地向前发展的。所以，不但小块红色区域的长期存在没有疑义，而且这些红色区域将继续发展，日渐接近于全国政权的取得。第四，相当力量的正式红军的存在，是红色政权存在的必要条件。若只有地方性质的赤卫队[9]而没有正式的红军，则只能对付挨户团[10]，而不能对付正式的白色军队。所以虽有很好的工农群众，若没有相当力量的正式武装，便决然不能造成割据局面，更不能造成长期的和日益发展的割据局面。所以“工农武装割据”的思想，是共产党和割据地方的工农群众必须充分具备的一个重要的思想。第五，红色政权的长期的存在并且发展，除了上述条件之外，还须有一个要紧的条件，就是共产党组织的有力量和它的政策的不错误。 毛泽东写这篇文章时正值第二次革命战争时期，由毛泽东同志所领导的秋收起义和周恩来、朱德等同志所领导的“八．一”南昌起义两支队伍会师井冈山，建立了我党领导的第一个革命根据地。从此，在半封建半殖民地的旧中国的土地上有了属于人民自己的红色政权。它的诞生，使祖祖辈辈受剥削、受压迫的劳动人民看到了希望，看到了曙光，因为共产党所领导的红色政权是人民自己的政权，是为广大劳苦大众谋利益的。在此之前，由于以陈独秀为代表的右倾机会主义者，在第一次国共合作时，没有坚决执行无产阶级自己的领导权，一贯向以蒋介石为代表的国民党右派势力妥协，结果被大地主、大资产阶级篡夺了领导权，以反革命代替了革命。正如毛泽东同志在文章中所提到的“中国迫切需要一个资产阶级的民主革命，这个革命必须由无产阶级领导才能完成。事实也正是这样，1927年蒋介石悍然发动的“四．一二”反革命政变就是如此，血的教训告诉我们，中国共产党如果不掌握自己的革命武装，建立属于自己的红色政权，就不能取得革命的最后胜利 本本主义的社会科学研究法也同样是最危险的，甚至可能走上反革命的道路，中国有许多专门从书本上讨生活的从事社会科学研究的共产党员，不是一批一批地成了反革命吗?就是明显的证据。我们说马克思主义是对的，决不是因为马克思这个人是什么“先哲”，而是因为他的理论，在我们的实践中，在我们的斗争中，证明了是对的。我们的斗争需要马克思主义。我们欢迎这个理论，丝毫不存什么“先哲”一类的形式的甚至神秘的念头在里面。读过马克思主义“本本”的许多人，成了革命叛徒，那些不识字的工人常常能够很好地掌握马克思主义。马克思主义的“本本”是要学习的，但是必须同我国的实际情况相结合。我们需要“本本”，但是一定要纠正脱离实际情况的本本主义。 本本主义即教条主义, 该文从认识论的高度阐明调查研究的重要性，提出了传之后世的“没有调查,就没有发言权”、“中国革命斗争的胜利要靠中国同志了解中国情况”等著名论断，是对马克思主义认识论和历史唯物主义的丰富和发展，蕴含着实事求是、群众路线、独立自主的基本思想，是中国共产党思想路线的雏形。明确表达了实事求是、群众路线、独立自主的基本观点，阐明了中国的马克思主义者对待马克思主义的态度。毛泽东在《反对本本主义》中倡导的实事求是、群众路线、独立自主的精神，对于今日中国落实“四个全面”仍具有重要理论意义与实践价值。 邓小平文选帝国主义的各种花样直到封锁，其目的在于迫我就范，我们的斗争也在于迫使帝国主义就范。我们绝不会就帝国主义之范，而一个多月的经验看出，帝国主义就我之范亦非易事。这一时期双方斗争实际上都是试探的性质，直到英美摊出封锁的牌。封锁，在目前说来，虽增加我们不少困难，但对我仍属有利，即使不封锁，我们许多困难也是不能解决的。但封锁太久了，对我则是极不利的。打破封锁之道，毛主席强调从军事上迅速占领两广云贵川康青宁诸省，尽量求得早日占领沿海各岛及台湾。同时我们提出的外交政策的一面倒，愈早表现于行动则对我愈有利（毛主席说，这样是主动的倒，免得将来被动的倒）；内部政策强调认真的从自力更生打算，不但叫，而且认真着手做（毛主席说，更主要的从长远的新民主主义建设着眼来提出这个问题），毛主席说这两条很好，与中央精神一致。我们这样做，即占领全国、一面倒和自力更生，不但可以立于坚固的基础之上，而且才有可能迫使帝国主义就我之范。 在当前疫情与美帝国主义为首的西方老牌资本主义国家对中国的围追堵截，技术封锁，贸易壁垒的大背景下，邓小平指出了我们绝不投降的方针，清晰的分析的当时的国际形式对国内的影响恰如今日，今天面对技术的封锁与列强的欺压。我国保持着比较强硬的外交政策。经济全球化的今天，国内有不少量的技术依赖于外国，这次收到技术封锁我们只能自力更生，没有就从零开始追赶。美国政府的欺压只会激发中国人的斗志，相信在未来，外国发达资本主义国家对于中国的技术优势只会越来越少甚至被反超。中国的国际地位将会极大的提升，同时配合中国提出的一系列贸易政策以中国为中心的三级贸易圈将会逐渐成熟，国内的低端产业将会如现在一样逐渐向发展中国家迁移，国内的产业将会进一步升级到高端产业。届时，中国将会收割以中国为中心的三级贸易圈的财富，国民的生活水平会逐步提高，这是建立在国内财富分配进一步优化的前提下的。如果如今天一样继续内卷下去，即使可以收割世界的财富，国内中产阶级无产阶级的生活质量有可能继续下降。 习近平讲话系列改革开放以来，我们党始终高度重视正确处理改革发展稳定关系，始终把维护国家安全和社会安定作为党和国家的一项基础性工作。我们保持了我国社会大局稳定，为改革开放和社会主义现代化建设营造了良好环境。“安而不忘危，存而不忘亡，治而不忘乱。”同时，必须清醒地看到，新形势下我国国家安全和社会安定面临的威胁和挑战增多，特别是各种威胁和挑战联动效应明显。我们必须保持清醒头脑、强化底线思维，有效防范、管理、处理国家安全风险，有力应对、处置、化解社会安定挑战。 要加强新形势下反分裂斗争，高举各民族大团结的旗帜，坚持各民族共同团结奋斗、共同繁荣发展的主题，深入开展民族团结宣传教育，打牢民族团结的思想基础，最大限度团结各族群众。要加强基层组织和基层政权建设，多做深入细致的群众工作。要正确把握党的民族、宗教政策，及时妥善解决影响民族团结的矛盾纠纷，坚决遏制和打击境内外敌对势力利用民族问题进行的分裂、渗透、破坏活动。 国家安全是国家生存和发展最基本最重要的前提。自2014年香港“非法占中”以来，港独思潮频频在香港社会抬头。一些分离分子企图通过对民族自决的歪曲，以全民公投的形式谋求“香港独立”；也常有独派借言论自由的名义大肆宣传港独思潮。港独思潮作为一种极端本土主义，若任其自由发展而不采取任何有效措施，必然给香港和内地社会繁荣与稳定带来不可忽略的破坏。在其嚣张的气焰背后不难发现有境外反华势力的支持。这只是众多案例之一，显而易见我国国家安全和社会安定面临的威胁和挑战增多，习主席的讲话对于国家安全问题做了新的概括，顺应时代发展的潮流，回应了广大人民的关切，有十分重要的指导意义。 维护国家安全，必须做好维护社会和谐稳定工作，做好预防化解社会矛盾工作，从制度、机制、政策、工作上积极推动社会矛盾预防化解工作。要增强发展的全面性、协调性、可持续性，加强保障和改善民生工作，从源头上预防和减少社会矛盾的产生。要以促进社会公平正义、增进人民福祉为出发点和落脚点，加大协调各方面利益关系的力度，推动发展成果更多更公平惠及全体人民。要完善和落实维护群众合法权益的体制机制，完善和落实社会稳定风险评估机制，预防和减少利益冲突。要全面推进依法治国，更好维护人民群众合法权益。对各类社会矛盾，要引导群众通过法律程序、运用法律手段解决，推动形成办事依法、遇事找法、解决问题用法、化解矛盾靠法的良好环境。 看到社会层面的指导方针我感慨万千，中国特色社会主义的道路还是很漫长和曲折的。必须要有党的正确的具有前瞻性和胆魄的指导以及人民群众的努力建设才能走下去。 我们党作为百年大党，如何永葆先进性和纯洁性、永葆青春活力，如何永远得到人民拥护和支持，如何实现长期执政，是我们必须回答好、解决好的一个根本性问题。我们党要求全党同志不忘初心、牢记使命，就是要提醒全党同志，党的初心和使命是党的性质宗旨、理想信念、奋斗目标的集中体现，越是长期执政，越不能丢掉马克思主义政党的本色，越不能忘记党的初心使命，越不能丧失自我革命精神。 我们党的初心和使命是建立在马克思主义科学理论基础之上的。马克思、恩格斯在《共产党宣言》中庄严宣告：“过去的一切运动都是少数人的，或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的，为绝大多数人谋利益的独立的运动。”我们党是用马克思主义武装起来的政党，始终把为中国人民谋幸福、为中华民族谋复兴作为自己的初心和使命，并一以贯之体现到党的全部奋斗之中。忘记这个初心和使命，党就会改变性质、改变颜色，就会失去人民、失去未来。只要我们党牢牢坚持立党为公、执政为民，牢牢坚持为中国人民谋幸福、为中华民族谋复兴，不断检视自己，不掩饰缺点，不文过饰非，坚决同一切弱化党的先进性和纯洁性、危害党的肌体健康的现象作斗争，就一定能够始终立于不败之地。 有这样能自省的，始终为人民着想，为人民谋幸福，坚定维护主权，国家利益和人民利益的政党领导，我觉得中国人民是十分幸福的，放眼全世界，有几个国家的政府是这样的呢？这就是人民当家作主，这就是社会主义的优越性之一吧，没有西方资本主义国家的功利，是有人情味的政党。希望我们党能坚守初心，不被资本腐蚀，能继续努力为人民谋幸福，建设更美好的国家。","categories":[],"tags":[{"name":"课后作业","slug":"课后作业","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"}]},{"title":"Hello Blog","slug":"hello-world","date":"2020-10-06T15:48:52.542Z","updated":"2020-10-07T04:26:18.564Z","comments":true,"path":"2020/10/06/hello-world/","link":"","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/2020/10/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start hello blog Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"基础学习","slug":"基础学习","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"name":"引用备忘","slug":"引用备忘","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E5%BC%95%E7%94%A8%E5%A4%87%E5%BF%98/"},{"name":"课后作业","slug":"课后作业","permalink":"https://github.com/FeOAr/FeOAr.github.io.git/tags/%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"}]}